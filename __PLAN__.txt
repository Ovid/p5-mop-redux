
Core Features Needed:

- pluggable MRO
    - current the MRO only supports the two 
      built ins (c3 and dfs)
    - MRO needs an API such that it is possible
      to register and write one either in Perl 
      or in C

MOP plan:

- the pluggable MRO handles any custom dispatch needed
    - when a old-style class is encountered
        - fall back to the old style dispatch
- the syntax is fixed (class, has, method, submethod)
    - the implementation is semi-fixed
        - 'has' creates attributes 
            - it passes a storage fieldhash to 'has'
                - using fieldhash as storage means
                    - we don't care about instance type
                    - we can easily wrap old style classes and instances
            - it passes metadata to 'has'
        - 'method' creates methods
            - methods accept simple parameters
                - positional & positional w/default
            - the method has a pre-amble that ...
                - creates $self
                - aliases attribute variables 
                    - with setter magic to write back to storage fieldhash
        - 'submethod' creates method
            - MRO decides how this is handled
                - should act as a private method
        - 'class' creates metaclass
            - can control the metaclasses used for 'has', 'method', 'submethod'
            - gets metadata 
- the mop should be simple
    - bootstrapping just adds a lot of complexity overhead
        - manual bootstrapping is tedious, but easier to maintain
    - the mop should have some simple events
        - these can be used to generate accessors, etc.
        - subclasses can override events to add behaviors

------------------------------------------------------

MOP plans:

- write it entirely within simple Pure Perl
    - the mro will work to inherit from it
        - all should be well

------------------------------------------------------

Compilation plan:

For the class itself, delay this for the moment:

    push @PLAN => 'package ' . $class->name;
    push @PLAN => 'use strict';
    push @PLAN => 'use warnings';
    push @PLAN => 'use mro';
    push @PLAN => 'mro::set_mro(q[' . $class->name . '], q[mop])';
    push @PLAN => 'use Variable::Magic qw[ wizard cast ]';
    push @PLAN => 'use Hash::Util::FieldHash qw[ fieldhash ]';
    push @PLAN => q/my $__wiz__ = wizard(
        data => sub { $_[1] },
        set  => sub { $_[1]->[0]->{ $_[1]->[1] } = $_[0] },
    )/;

Collect for each attribute:

    push @PLAN => 'fieldhash my %' . $attr->key_name;

The first time we see a method, we need to eval the plan:



------------------------------------------------------

- mop MRO should use WALKCLASS, WALKMETH, NEXTMETHOD, etc. 
    - these should support both MOP based dispatch and traditional based dispatch
        - this can be determined by the type of instance

- instance should hold class as well as instance data
    - should be based on some kind of opaque scalar ref
        - perhaps store the data as inside-out (fieldhashes)

# This:

class Foo {
    has $bar;
    has $baz;

    method bar { ... }
}

# expands to this:
package Foo {
    # strict and warnings should be on
    use strict;
    use warnings;

    # set the MRO to use the MOP based
    # MRO, which will dispatch via the
    # MOP instead of packages 
    # (using MRO::Define)
    use mro 'mop';

    # for each attribute, make a fieldhash
    # that corresponds to them.
    fieldhash %bar;
    fieldhash %baz;   

    # create a constructor ...
    sub new {
        # insert constructor magic here 
        # to assemble the class from the 
        # parameters passed in

        # can reliably bless into __PACKAGE__
        # because we will generate a constructor 
        # for every class (maybe, think about it)
        bless \(my $x) => __PACKAGE__;
    } 

    # methods get an automagically injected
    # preamble to support a set of features 
    sub bar {
        # the invocant is set ...
        my $self  = shift;
        # the class is set ...
        my $class = __PACKAGE__;

        # create a local variable for each 
        # of the attributes and ...
        my $bar = $bar{ $self };
        my $baz = $baz{ $self };

        # cast Variable::Magic on it to 
        # make any changes to the variable
        # also store back in the fieldhash
        cast $bar, $inside_out_wizards, \%bar;
        cast $baz, $inside_out_wizards, \%baz;

        # at this point, the rest of the 
        # method body can be executed
        ...
    }

    # finally create the metaclass 
    # that we can use to access the 
    # properties of this class
    my $META = mop::class->new( %metadata_collected_during_compile );

    # add an accessor to 
    # the metaclass
    sub meta { $META }
}






This is going to be a layered system.

[.] create a custom MRO (using MRO::Define) that dispatches to a set of methods and submethods
[ ] create a syntax to support method and submethod
[ ] build simple MOP on top of this
    [ ] add attributes
        [ ] accessors can be submethods for private
        [ ] and regular accessors for ro/rw
    [ ] allows access to methods and submethods
        [ ] to support BUILDALL, DEMOLISHALL, etc.
[ ] create base Object class
    [ ] handles new, etc.

Possible ideas:

- attribute access as lexicals
    - instead of PadWalker, compile it in with syntax module
- first class Classes
    - make the actual package be Thing::internal
        - and make Thing a subroutine in package


